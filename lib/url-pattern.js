// Generated by CoffeeScript 1.9.2
var slice = [].slice;

(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define([], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory();
  } else {
    return root.UrlPattern = factory();
  }
})(this, function() {
  var P, UrlPattern, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultParser, escapeForRegex, newParser, regexGroupCount, stringConcatMap, stringify;
  escapeForRegex = function(string) {
    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  };
  concatMap = function(array, f) {
    var i, length, results;
    results = [];
    i = -1;
    length = array.length;
    while (++i < length) {
      results = results.concat(f(array[i]));
    }
    return results;
  };
  stringConcatMap = function(array, f) {
    var i, length, result;
    result = '';
    i = -1;
    length = array.length;
    while (++i < length) {
      result += f(array[i]);
    }
    return result;
  };
  regexGroupCount = function(regex) {
    return (new RegExp(regex.toString() + '|')).exec('').length - 1;
  };
  P = {};
  P.Result = function(value, rest) {
    this.value = value;
    this.rest = rest;
  };
  P.Tagged = function(tag, value) {
    this.tag = tag;
    this.value = value;
  };
  P.tag = function(tag, parser) {
    return function(input) {
      var result, tagged;
      result = parser(input);
      if (!result) {
        return;
      }
      tagged = new P.Tagged(tag, result.value);
      return new P.Result(tagged, result.rest);
    };
  };
  P.regex = function(arg) {
    var regex;
    regex = 'string' === typeof arg ? new RegExp('^' + arg) : arg;
    return function(input) {
      var matches, result;
      matches = regex.exec(input);
      if (matches == null) {
        return;
      }
      result = matches[0];
      return new P.Result(result, input.slice(result.length));
    };
  };
  P.sequence = function() {
    var parsers;
    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(input) {
      var i, length, parser, rest, result, values;
      i = -1;
      length = parsers.length;
      values = [];
      rest = input;
      while (++i < length) {
        parser = parsers[i];
        if ('function' !== typeof parser) {
          throw new Error("parser passed at index `" + i + "` into `sequence` is not of type `function` but of type `" + (typeof parser) + "`");
        }
        result = parser(rest);
        if (result == null) {
          return;
        }
        values.push(result.value);
        rest = result.rest;
      }
      return new P.Result(values, rest);
    };
  };
  P.pick = function() {
    var indexes, parsers;
    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return function(input) {
      var array, result;
      result = P.sequence.apply(P, parsers)(input);
      if (result == null) {
        return;
      }
      array = result.value;
      if (!Array.isArray(indexes)) {
        result.value = array[indexes];
      } else {
        result.value = [];
        indexes.forEach(function(i) {
          return result.value.push(array[i]);
        });
      }
      return result;
    };
  };
  P.string = function(string) {
    var length;
    length = string.length;
    if (length === 0) {
      throw new Error('`string` must not be blank');
    } else if (length === 1) {
      return function(input) {
        if (input.charAt(0) === string) {
          return new P.Result(string, input.slice(1));
        }
      };
    } else {
      return function(input) {
        if (input.slice(0, length) === string) {
          return new P.Result(string, input.slice(length));
        }
      };
    }
  };
  P.anyChar = function(input) {
    if (input === '') {
      return;
    }
    return new P.Result(input.charAt(0), input.slice(1));
  };
  P.lazy = function(fn) {
    var cached;
    cached = null;
    return function(input) {
      if (cached == null) {
        cached = fn();
      }
      return cached(input);
    };
  };
  P.charset = function(charset) {
    var regex;
    regex = new RegExp('^[' + charset + ']$');
    return function(input) {
      var char;
      char = input.charAt(0);
      if (!regex.test(char)) {
        return;
      }
      return new P.Result(char, input.slice(1));
    };
  };
  P.baseMany = function(parser, end, stringResult, atLeastOneResultRequired, input) {
    var endResult, parserResult, rest, results;
    rest = input;
    results = stringResult ? '' : [];
    while (true) {
      if (end != null) {
        endResult = end(rest);
        if (endResult != null) {
          break;
        }
      }
      parserResult = parser(rest);
      if (parserResult == null) {
        break;
      }
      if (stringResult) {
        results += parserResult.value;
      } else {
        results.push(parserResult.value);
      }
      rest = parserResult.rest;
    }
    if (atLeastOneResultRequired && results.length === 0) {
      return;
    }
    return new P.Result(results, rest);
  };
  P.concatMany1Till = function(parser, end) {
    return function(input) {
      return P.baseMany(parser, end, true, true, input);
    };
  };
  P.firstChoice = function() {
    var parsers;
    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    return function(input) {
      var i, length, parser, result;
      i = -1;
      length = parsers.length;
      while (++i < length) {
        parser = parsers[i];
        if ('function' !== typeof parser) {
          throw new Error("parser passed at index `" + i + "` into `firstChoice` is not of type `function` but of type `" + (typeof parser) + "`");
        }
        result = parser(input);
        if (result != null) {
          return result;
        }
      }
    };
  };
  P.many1 = function(parser) {
    return function(input) {
      return P.baseMany(parser, null, false, true, input);
    };
  };
  newParser = function(options) {
    var U;
    U = {};
    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));
    U.name = P.regex('^[a-zA-Z0-9]+');
    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function() {
      return U.pattern;
    }), P.string(options.optionalSegmentEndChar)));
    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function() {
      return U.name;
    })));
    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.anyChar);
    U["static"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function() {
      return U.escapedChar;
    }), P.anyChar), P.charset('\\*\\(\\):')));
    U.token = P.lazy(function() {
      return P.firstChoice(U.wildcard, U.optional, U.named, U["static"]);
    });
    U.pattern = P.many1(P.lazy(function() {
      return U.token;
    }));
    return U;
  };
  defaultParser = newParser({
    escapeChar: '\\',
    segmentNameStartChar: ':',
    optionalSegmentStartChar: '(',
    optionalSegmentEndChar: ')',
    wildcardChar: '*'
  });
  baseAstNodeToRegexString = function(astNode) {
    if (Array.isArray(astNode)) {
      return astNode.map(baseAstNodeToRegexString).join('');
    }
    if (astNode.tag === 'wildcard') {
      return '(.*?)';
    }
    if (astNode.tag === 'named') {
      return '([a-zA-Z0-9-_~ %]+)';
    }
    if (astNode.tag === 'static') {
      return escapeForRegex(astNode.value);
    }
    if (astNode.tag === 'optional') {
      return '(?:' + baseAstNodeToRegexString(astNode.value) + ')?';
    }
  };
  astNodeToRegexString = function(astNode) {
    return '^' + baseAstNodeToRegexString(astNode) + '$';
  };
  astNodeToNames = function(astNode) {
    var i, length, results;
    if (Array.isArray(astNode)) {
      results = [];
      i = -1;
      length = astNode.length;
      while (++i < length) {
        results = results.concat(astNodeToNames(astNode[i]));
      }
      return results;
    }
    if (astNode.tag === 'wildcard') {
      return ['_'];
    }
    if (astNode.tag === 'named') {
      return [astNode.value];
    }
    if (astNode.tag === 'static') {
      return [];
    }
    if (astNode.tag === 'optional') {
      return astNodeToNames(astNode.value);
    }
  };
  stringify = function(astNode, params) {};
  UrlPattern = function(arg1, arg2) {
    var groupCount, parsed, withoutWhitespace;
    if (arg1 instanceof UrlPattern) {
      this.isRegex = arg1.isRegex;
      this.regex = arg1.regex;
      this.ast = arg1.ast;
      this.names = arg1.names;
      return;
    }
    this.isRegex = arg1 instanceof RegExp;
    if (!(('string' === typeof arg1) || this.isRegex)) {
      throw new TypeError('argument must be a regex or a string');
    }
    if (this.isRegex) {
      this.regex = arg1;
      if (arg2 != null) {
        if (!Array.isArray(arg2)) {
          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');
        }
        groupCount = regexGroupCount(this.regex);
        if (arg2.length !== groupCount) {
          throw new Error("regex contains " + groupCount + " groups but array of group names contains " + arg2.count);
        }
        this.names = arg2;
      }
      return;
    }
    if (arg1 === '') {
      throw new Error('argument must not be the empty string');
    }
    withoutWhitespace = arg1.replace(/\s+/g, '');
    if (withoutWhitespace !== arg1) {
      throw new Error('argument must not contain whitespace');
    }
    parsed = defaultParser.pattern(arg1);
    if (parsed == null) {
      throw new Error("couldn't parse pattern");
    }
    if (parsed.rest !== '') {
      throw new Error("could only partially parse pattern");
    }
    this.ast = parsed.value;
    this.regex = new RegExp(astNodeToRegexString(this.ast));
    this.names = astNodeToNames(this.ast);
  };
  UrlPattern.prototype.match = function(url) {
    var bound, captured, i, length, match, name, value;
    match = this.regex.exec(url);
    if (match == null) {
      return null;
    }
    captured = match.slice(1);
    if (this.isRegex) {
      return captured;
    }
    bound = {};
    i = -1;
    length = captured.length;
    while (++i < length) {
      value = captured[i];
      name = this.names[i];
      if (value == null) {
        continue;
      }
      if (bound[name] != null) {
        if (!Array.isArray(bound[name])) {
          bound[name] = [bound[name]];
        }
        bound[name].push(value);
      } else {
        bound[name] = value;
      }
    }
    return bound;
  };
  UrlPattern.prototype.stringify = function(params) {
    return stringify(this.ast, params);
  };
  UrlPattern.escapeForRegex = escapeForRegex;
  UrlPattern.concatMap = concatMap;
  UrlPattern.stringConcatMap = stringConcatMap;
  UrlPattern.regexGroupCount = regexGroupCount;
  UrlPattern.P = P;
  UrlPattern.newParser = newParser;
  UrlPattern.defaultParser = defaultParser;
  UrlPattern.astNodeToRegexString = astNodeToRegexString;
  UrlPattern.astNodeToNames = astNodeToNames;
  UrlPattern.stringify = stringify;
  return UrlPattern;
});
