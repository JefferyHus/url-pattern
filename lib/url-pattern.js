// Generated by CoffeeScript 1.9.2
(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define([], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory();
  } else {
    return root.UrlPattern = factory();
  }
})(this, function() {
  var UrlPattern, alphanumericRegex;
  UrlPattern = function(arg, allowedSegmentChars) {
    if (allowedSegmentChars) {
      this.allowedSegmentChars = allowedSegmentChars;
    }
    if (arg instanceof UrlPattern) {
      this.isRegex = arg.isRegex;
      this.regex = arg.regex;
      this.names = arg.names;
      return this;
    }
    this.isRegex = arg instanceof RegExp;
    if (!(('string' === typeof arg) || this.isRegex)) {
      throw new TypeError('argument must be a regex or a string');
    }
    if (this.isRegex) {
      this.regex = arg;
    } else {
      this.compile(arg);
    }
    return this;
  };
  UrlPattern.prototype.allowedSegmentChars = 'a-zA-Z0-9-_ %';
  UrlPattern.prototype.match = function(url) {
    var bound, captured, i, j, len, match, name, value;
    match = this.regex.exec(url);
    if (match == null) {
      return null;
    }
    captured = match.slice(1);
    if (this.isRegex) {
      return captured;
    }
    bound = {};
    for (i = j = 0, len = captured.length; j < len; i = ++j) {
      value = captured[i];
      name = this.names[i];
      if (value == null) {
        continue;
      }
      if (bound[name] != null) {
        if (!Array.isArray(bound[name])) {
          bound[name] = [bound[name]];
        }
        bound[name].push(value);
      } else {
        bound[name] = value;
      }
    }
    return bound;
  };
  alphanumericRegex = new RegExp('^[a-zA-Z0-9]+$');
  UrlPattern.prototype.isAlphanumeric = function(string) {
    return alphanumericRegex.test(string);
  };
  UrlPattern.prototype.escapeForRegex = function(string) {
    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  };
  UrlPattern.prototype.compile = function(string) {
    var char, enter, index, leave, length, mode, names, openParens, regexString, sliceBegin, that;
    names = [];
    regexString = '^';
    mode = '?';
    sliceBegin = 0;
    openParens = 0;
    that = this;
    index = -1;
    leave = function() {
      switch (mode) {
        case 'variable':
          if ((index - sliceBegin) < 2) {
            throw new Error("`:` must be followed by at least one alphanumeric character that is the variable name at " + index);
          }
          names.push(string.slice(sliceBegin + 1, index));
          regexString += "([" + that.allowedSegmentChars + "]+)";
          break;
        case 'static':
          regexString += that.escapeForRegex(string.slice(sliceBegin, index));
      }
      return mode = '?';
    };
    enter = function(nextMode) {
      if (nextMode === mode) {
        return;
      }
      leave();
      sliceBegin = index;
      return mode = nextMode;
    };
    length = string.length;
    while (++index < length) {
      char = string.charAt(index);
      if (char === ':') {
        if (mode === 'variable') {
          throw new Error("cannot start variable right after variable at " + index);
        }
        enter('variable');
      } else if (char === '(') {
        leave();
        openParens++;
        regexString += '(?:';
      } else if (char === ')') {
        leave();
        openParens--;
        if (openParens < 0) {
          throw new Error("did not expect ) at " + index);
        }
        regexString += ')?';
      } else if (char === '*') {
        leave();
        regexString += '(.*?)';
        names.push('_');
      } else {
        switch (mode) {
          case 'variable':
            if (!this.isAlphanumeric(char)) {
              enter('static');
            }
            break;
          case '?':
            enter('static');
        }
      }
    }
    if (openParens > 0) {
      throw new Error("unclosed parentheses at " + index);
    }
    leave();
    regexString += '$';
    this.names = names;
    return this.regex = new RegExp(regexString);
  };
  UrlPattern.newPattern = function() {
    throw Error('`urlPattern.newPattern` is no longer supported.  Use `new Pattern` instead.');
  };
  return UrlPattern;
});
